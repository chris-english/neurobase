
R version 3.4.3 (2017-11-30) -- "Kite-Eating Tree"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "fslr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "fslr-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('fslr')
Loading required package: oro.nifti
oro.nifti 0.9.4
Loading required package: neurobase
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("check_file")
> ### * check_file
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_file
> ### Title: Wrapper for getForms with filename
> ### Aliases: check_file
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mnifile = file.path(fsldir(), "data", "standard", 
+    "MNI152_T1_2mm.nii.gz")
+  check_file(mnifile)
+ } 
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslhd "/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz" 

[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_file", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("checkout")
> ### * checkout
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: checkout
> ### Title: Determine of Q and S forms are consistent
> ### Aliases: checkout
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mnifile = file.path(fsldir(), "data", "standard", 
+    "MNI152_T1_2mm.nii.gz")
+  forms = getForms(mnifile)
+  checkout(forms)
+ } 
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslhd "/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz" 

[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("checkout", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fast.help")
> ### * fast.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fast.help
> ### Title: FAST help
> ### Aliases: fast.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fast.help()
+ }

Part of FSL (ID: 5.0.10)
FAST 
Copyright(c) 2004-2012, University of Oxford

Usage: 
fast [options] file(s)

Optional arguments (You may optionally specify one or more of):
	-n,--class	number of tissue-type classes; default=3
	-I,--iter	number of main-loop iterations during bias-field removal; default=4
	-l,--lowpass	bias field smoothing extent (FWHM) in mm; default=20
	-t,--type	type of image 1=T1, 2=T2, 3=PD; default=T1
	-f,--fHard	initial segmentation spatial smoothness (during bias field estimation); default=0.02
	-g,--segments	outputs a separate binary image for each tissue type
	-a <standard2input.mat> initialise using priors; you must supply a FLIRT transform
	-A <prior1> <prior2> <prior3>    alternative prior images
	--nopve	turn off PVE (partial volume estimation)
	-b		output estimated bias field
	-B		output bias-corrected image
	-N,--nobias	do not remove bias field
	-S,--channels	number of input images (channels); default 1
	-o,--out	output basename
	-P,--Prior	use priors throughout; you must also set the -a option
	-W,--init	number of segmentation-initialisation iterations; default=15
	-R,--mixel	spatial smoothness for mixeltype; default=0.3
	-O,--fixed	number of main-loop iterations after bias-field removal; default=4
	-H,--Hyper	segmentation spatial smoothness; default=0.1
	-v,--verbose	switch on diagnostic messages
	-h,--help	display this message
	-s,--manualseg <filename> Filename containing intensities
	-p		outputs individual probability maps




> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fast.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("flirt.help")
> ### * flirt.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: flirt.help
> ### Title: FLIRT help
> ### Aliases: flirt.help flirt_apply.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  flirt.help()
+ } 
FLIRT version 6.0Usage: /usr/local/fsl/bin/flirt [options] -in <inputvol> -ref <refvol> -out <outputvol>       /usr/local/fsl/bin/flirt [options] -in <inputvol> -ref <refvol> -omat <outputmatrix>       /usr/local/fsl/bin/flirt [options] -in <inputvol> -ref <refvol> -applyxfm -init <matrix> -out <outputvol>  Available options are:        -in  <inputvol>                    (no default)        -ref <refvol>                      (no default)        -init <matrix-filname>             (input 4x4 affine matrix)        -omat <matrix-filename>            (output in 4x4 ascii format)        -out, -o <outputvol>               (default is none)        -datatype {char,short,int,float,double}                    (force output data type)        -cost {mutualinfo,corratio,normcorr,normmi,leastsq,labeldiff,bbr}        (default is corratio)        -searchcost {mutualinfo,corratio,normcorr,normmi,leastsq,labeldiff,bbr}  (default is corratio)        -usesqform                         (initialise using appropriate sform or qform)        -displayinit                       (display initial matrix)        -anglerep {quaternion,euler}       (default is euler)        -interp {trilinear,nearestneighbour,sinc,spline}  (final interpolation: def - trilinear)        -sincwidth <full-width in voxels>  (default is 7)        -sincwindow {rectangular,hanning,blackman}        -bins <number of histogram bins>   (default is 256)        -dof  <number of transform dofs>   (default is 12)        -noresample                        (do not change input sampling)        -forcescaling                      (force rescaling even for low-res images)        -minsampling <vox_dim>             (set minimum voxel dimension for sampling (in mm))        -applyxfm                          (applies transform (no optimisation) - requires -init)        -applyisoxfm <scale>               (as applyxfm but forces isotropic resampling)        -paddingsize <number of voxels>    (for applyxfm: interpolates outside image by size)        -searchrx <min_angle> <max_angle>  (angles in degrees: default is -90 90)        -searchry <min_angle> <max_angle>  (angles in degrees: default is -90 90)        -searchrz <min_angle> <max_angle>  (angles in degrees: default is -90 90)        -nosearch                          (sets all angular search ranges to 0 0)        -coarsesearch <delta_angle>        (angle in degrees: default is 60)        -finesearch <delta_angle>          (angle in degrees: default is 18)        -schedule <schedule-file>          (replaces default schedule)        -refweight <volume>                (use weights for reference volume)        -inweight <volume>                 (use weights for input volume)        -wmseg <volume>                    (white matter segmentation volume needed by BBR cost function)        -wmcoords <text matrix>            (white matter boundary coordinates for BBR cost function)        -wmnorms <text matrix>             (white matter boundary normals for BBR cost function)        -fieldmap <volume>                 (fieldmap image in rads/s - must be already registered to the reference image)        -fieldmapmask <volume>             (mask for fieldmap image)        -pedir <index>                     (phase encode direction of EPI - 1/2/3=x/y/z & -1/-2/-3=-x/-y/-z)        -echospacing <value>               (value of EPI echo spacing - units of seconds)        -bbrtype <value>                   (type of bbr cost function: signed [default], global_abs, local_abs)        -bbrslope <value>                  (value of bbr slope)        -setbackground <value>             (use specified background value for points outside FOV)        -noclamp                           (do not use intensity clamping)        -noresampblur                      (do not use blurring on downsampling)        -2D                                (use 2D rigid body mode - ignores dof)        -verbose <num>                     (0 is least and default)        -v                                 (same as -verbose 1)        -i                                 (pauses at each stage: default is off)        -version                           (prints version number)        -help

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("flirt.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fsl_anat.help")
> ### * fsl_anat.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_anat.help
> ### Title: fsl_anat help
> ### Aliases: fsl_anat.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fsl_anat.help()
+ }
Usage: fsl_anat [options] -i <structural image>       fsl_anat [options] -d <existing anat directory> Arguments (You may specify one or more of):  -i <strucural image>         filename of input image (for one image only)  -d <anat dir>                directory name for existing .anat directory where this script will be run in place  -o <output directory>        basename of directory for output (default is input image basename followed by .anat)  --clobber                    if .anat directory exist (as specified by -o or default from -i) then delete it and make a new one  --strongbias                 used for images with very strong bias fields  --weakbias                   used for images with smoother, more typical, bias fields (default setting)  --noreorient                 turn off step that does reorientation 2 standard (fslreorient2std)  --nocrop                     turn off step that does automated cropping (robustfov)  --nobias                     turn off steps that do bias field correction (via FAST)  --noreg                      turn off steps that do registration to standard (FLIRT and FNIRT)  --nononlinreg                turn off step that does non-linear registration (FNIRT)  --noseg                      turn off step that does tissue-type segmentation (FAST)  --nosubcortseg               turn off step that does sub-cortical segmentation (FIRST)  -s <value>                   specify the value for bias field smoothing (the -l option in FAST)  -t <type>                    specify the type of image (choose one of T1 T2 PD - default is T1)  --nosearch                   specify that linear registration uses the -nosearch option (FLIRT)  --betfparam                  specify f parameter for BET (only used if not running non-linear reg and also wanting brain extraction done)  --nocleanup                  do not remove intermediate files 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fsl_anat.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fsl_version")
> ### * fsl_version
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_version
> ### Title: Find FSL Version
> ### Aliases: fsl_version fslversion
> 
> ### ** Examples
> 
> if (have_fsl()) {
+  fslversion()
+  fsl_version()
+ }
Warning in readLines(version_file) :
  incomplete final line found on '/usr/local/fsl/etc/fslversion'
Warning in readLines(version_file) :
  incomplete final line found on '/usr/local/fsl/etc/fslversion'
[1] "5.0.10"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fsl_version", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslabs.help")
> ### * fslabs.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslabs.help
> ### Title: fslabs Help
> ### Aliases: fslabs.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslabs.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslabs.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslacos.help")
> ### * fslacos.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslacos.help
> ### Title: fslacos Help
> ### Aliases: fslacos.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslacos.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslacos.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fsladd.help")
> ### * fsladd.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsladd.help
> ### Title: fsladd Help
> ### Aliases: fsladd.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fsladd.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fsladd.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslasin.help")
> ### * fslasin.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslasin.help
> ### Title: fslasin Help
> ### Aliases: fslasin.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslasin.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslasin.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslatan.help")
> ### * fslatan.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslatan.help
> ### Title: fslatan Help
> ### Aliases: fslatan.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslatan.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslatan.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslbet.help")
> ### * fslbet.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslbet.help
> ### Title: Help for FSL BET
> ### Aliases: fslbet.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslbet.help()
+  fslbet.help("bet")
+ }  

Part of FSL (ID: 5.0.10)
BET (Brain Extraction Tool) v2.1 - FMRIB Analysis Group, Oxford

Usage: 
bet2 <input_fileroot> <output_fileroot> [options]

Optional arguments (You may optionally specify one or more of):
	-o,--outline	generate brain surface outline overlaid onto original image
	-m,--mask	generate binary brain mask
	-s,--skull	generate approximate skull image
	-n,--nooutput	don't generate segmented brain image output
	-f <f>		fractional intensity threshold (0->1); default=0.5; smaller values give larger brain outline estimates
	-g <g>		vertical gradient in fractional intensity threshold (-1->1); default=0; positive values give larger brain outline at bottom, smaller at top
	-r,--radius <r>	head radius (mm not voxels); initial surface sphere is set to half of this
	-w,--smooth <r>	smoothness factor; default=1; values smaller than 1 produce more detailed brain surface, values larger than one produce smoother, less detailed surface
	-c <x y z>	centre-of-gravity (voxels not mm) of initial mesh surface.
	-t,--threshold	-apply thresholding to segmented brain image and mask
	-e,--mesh	generates brain surface as mesh in vtk format
	-v,--verbose	switch on diagnostic messages
	-h,--help	displays this help, then exits




Usage:    bet <input> <output> [options]Main bet2 options:  -o          generate brain surface outline overlaid onto original image  -m          generate binary brain mask  -s          generate approximate skull image  -n          don't generate segmented brain image output  -f <f>      fractional intensity threshold (0->1); default=0.5; smaller values give larger brain outline estimates  -g <g>      vertical gradient in fractional intensity threshold (-1->1); default=0; positive values give larger brain outline at bottom, smaller at top  -r <r>      head radius (mm not voxels); initial surface sphere is set to half of this  -c <x y z>  centre-of-gravity (voxels not mm) of initial mesh surface.  -t          apply thresholding to segmented brain image and mask  -e          generates brain surface as mesh in .vtk formatVariations on default bet2 functionality (mutually exclusive options):  (default)   just run bet2  -R          robust brain centre estimation (iterates BET several times)  -S          eye & optic nerve cleanup (can be useful in SIENA)  -B          bias field & neck cleanup (can be useful in SIENA)  -Z          improve BET if FOV is very small in Z (by temporarily padding end slices)  -F          apply to 4D FMRI data (uses -f 0.3 and dilates brain mask slightly)  -A          run bet2 and then betsurf to get additional skull and scalp surfaces (includes registrations)  -A2 <T2>    as with -A, when also feeding in non-brain-extracted T2 (includes registrations)Miscellaneous options:  -v          verbose (switch on diagnostic messages)  -h          display this help, then exits  -d          debug (don't delete temporary intermediate images)

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslbet.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslbin")
> ### * fslbin
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_bin
> ### Title: Binarize Image using FSL
> ### Aliases: fsl_bin fslbin
> 
> ### ** Examples
> 
>   set.seed(5)
> dims = rep(10, 3)
> arr = array(rnorm(prod(dims)), dim = dims)
> nim = oro.nifti::nifti(arr)
> if (have.fsl()){
+  fslbin(nim)
+  fsl_bin(nim)
+  }
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6259a31e01.nii.gz"  -bin   "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d62640701a0";

FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d627fbe2ae.nii.gz"  -bin   "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d6229df119a";

[1] "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d6229df119a.nii.gz"
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslbin", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslbin.help")
> ### * fslbin.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslbin.help
> ### Title: fslbin Help
> ### Aliases: fslbin.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslbin.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslbin.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslbinv.help")
> ### * fslbinv.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslbinv.help
> ### Title: fslbinv Help
> ### Aliases: fslbinv.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslbinv.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslbinv.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslchfiletype.help")
> ### * fslchfiletype.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslchfiletype.help
> ### Title: fslchfiletype help
> ### Aliases: fslchfiletype.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslchfiletype.help()
+ }  
Usage: /usr/local/fsl/bin/fslchfiletype <filetype> <filename> [filename2]   Changes the file type of the image file, or copies to new file  Valid values of filetype are ANALYZE, NIFTI, NIFTI_PAIR,                                 ANALYZE_GZ, NIFTI_GZ, NIFTI_PAIR_GZ

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslchfiletype.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslcog")
> ### * fslcog
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslcog
> ### Title: Image Center of Gravity (FSL)
> ### Aliases: fslcog
> 
> ### ** Examples
> 
> if (have.fsl()){
+ x = array(rnorm(1e6), dim = c(100, 100, 100))
+ img = nifti(x, dim= c(100, 100, 100), 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ fslcog(img)
+ }
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslstats  "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6273fcaaef.nii.gz" -c

[1] 49.50170 49.49233 49.50567
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslcog", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslcos.help")
> ### * fslcos.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslcos.help
> ### Title: fslcos Help
> ### Aliases: fslcos.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslcos.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslcos.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslcpgeom.help")
> ### * fslcpgeom.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslcpgeom.help
> ### Title: fslcpgeom help
> ### Aliases: fslcpgeom.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslcpgeom.help()
+ }  
Usage: fslcpgeom <source> <destination> [-d]-d : don't copy image dimensions

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslcpgeom.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fsldilate")
> ### * fsldilate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_dilate
> ### Title: Dilate image using FSL
> ### Aliases: fsl_dilate fsldilate
> 
> ### ** Examples
> 
> if (have.fsl()){
+ system.time({
+ dims = c(50, 50, 20)
+ x = array(rnorm(prod(dims)), dim = dims) 
+ img = nifti(x, dim= dims, 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ mask = img > .5
+ dilated = fsldilate(mask, kopts = "-kernel boxv 5", retimg=TRUE)
+ })
+ }    
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6252a2c633.nii.gz" -bin -mul -1 -add 1 -kernel boxv 5 -ero -mul -1 -add 1  "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d62513a6c66"

   user  system elapsed 
  0.682   0.040   0.730 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fsldilate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fsldiv.help")
> ### * fsldiv.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsldiv.help
> ### Title: fsldiv Help
> ### Aliases: fsldiv.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fsldiv.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fsldiv.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fsledge.help")
> ### * fsledge.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsledge.help
> ### Title: fsledge Help
> ### Aliases: fsledge.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fsledge.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fsledge.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslerode")
> ### * fslerode
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_erode
> ### Title: Erode image using FSL
> ### Aliases: fsl_erode fslerode
> 
> ### ** Examples
> 
> if (have.fsl()){
+ system.time({
+ dims = c(50, 50, 20)
+ x = array(rnorm(prod(dims)), dim = dims) 
+ img = nifti(x, dim= dims, 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ mask = img > .5
+ eroded = fslerode(mask, kopts = "-kernel boxv 5", retimg=TRUE)
+ })
+ }    
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6215a4cafa.nii.gz" -kernel boxv 5 -ero  "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d623c8268a7"

   user  system elapsed 
  0.476   0.019   0.500 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslerode", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslerode.help")
> ### * fslerode.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslerode.help
> ### Title: fslerode Help
> ### Aliases: fslerode.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslerode.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslerode.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslexp.help")
> ### * fslexp.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslexp.help
> ### Title: fslexp Help
> ### Aliases: fslexp.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslexp.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslexp.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslfill")
> ### * fslfill
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_fill
> ### Title: Fill image holes
> ### Aliases: fsl_fill fslfill
> 
> ### ** Examples
> 
> if (have.fsl()){
+ system.time({
+ dims = c(50, 50, 20)
+ x = array(rnorm(prod(dims)), dim = dims) 
+ img = nifti(x, dim= dims, 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ mask = img > .5
+ eroded = fslerode(mask, kopts = "-kernel boxv 5", retimg=TRUE)
+ filled = fslfill(eroded, retimg= TRUE)
+ })
+ }  
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d625f48c34.nii.gz" -kernel boxv 5 -ero  "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d627609ee2f"

FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d62773c4e12.nii.gz" -bin -fillh "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d627a20acf9"

   user  system elapsed 
  0.543   0.044   0.595 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslfill", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslfill.help")
> ### * fslfill.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslfill.help
> ### Title: fslfill Help
> ### Aliases: fslfill.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslfill.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslfill.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslhd")
> ### * fslhd
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslhd
> ### Title: Get NIfTI header using FSL
> ### Aliases: fslhd
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mnifile = file.path(fsldir(), "data", "standard", 
+    "MNI152_T1_2mm.nii.gz")
+  fslhd(mnifile)
+ }   
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslhd "/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz" 

 [1] "filename       /usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz"
 [2] ""                                                                
 [3] "sizeof_hdr     348"                                              
 [4] "data_type      INT16"                                            
 [5] "dim0           3"                                                
 [6] "dim1           91"                                               
 [7] "dim2           109"                                              
 [8] "dim3           91"                                               
 [9] "dim4           1"                                                
[10] "dim5           1"                                                
[11] "dim6           1"                                                
[12] "dim7           1"                                                
[13] "vox_units      mm"                                               
[14] "time_units     s"                                                
[15] "datatype       4"                                                
[16] "nbyper         2"                                                
[17] "bitpix         16"                                               
[18] "pixdim0        0.000000"                                         
[19] "pixdim1        2.000000"                                         
[20] "pixdim2        2.000000"                                         
[21] "pixdim3        2.000000"                                         
[22] "pixdim4        1.000000"                                         
[23] "pixdim5        0.000000"                                         
[24] "pixdim6        0.000000"                                         
[25] "pixdim7        0.000000"                                         
[26] "vox_offset     352"                                              
[27] "cal_max        8000.0000"                                        
[28] "cal_min        3000.0000"                                        
[29] "scl_slope      1.000000"                                         
[30] "scl_inter      0.000000"                                         
[31] "phase_dim      0"                                                
[32] "freq_dim       0"                                                
[33] "slice_dim      0"                                                
[34] "slice_name     Unknown"                                          
[35] "slice_code     0"                                                
[36] "slice_start    0"                                                
[37] "slice_end      0"                                                
[38] "slice_duration 0.000000"                                         
[39] "time_offset    0.000000"                                         
[40] "intent         Unknown"                                          
[41] "intent_code    0"                                                
[42] "intent_name    "                                                 
[43] "intent_p1      0.000000"                                         
[44] "intent_p2      0.000000"                                         
[45] "intent_p3      0.000000"                                         
[46] "qform_name     MNI_152"                                          
[47] "qform_code     4"                                                
[48] "qto_xyz:1      -2.000000  0.000000  -0.000000  90.000000"        
[49] "qto_xyz:2      0.000000  2.000000  -0.000000  -126.000000"       
[50] "qto_xyz:3      0.000000  0.000000  2.000000  -72.000000"         
[51] "qto_xyz:4      0.000000  0.000000  0.000000  1.000000"           
[52] "qform_xorient  Right-to-Left"                                    
[53] "qform_yorient  Posterior-to-Anterior"                            
[54] "qform_zorient  Inferior-to-Superior"                             
[55] "sform_name     MNI_152"                                          
[56] "sform_code     4"                                                
[57] "sto_xyz:1      -2.000000  0.000000  0.000000  90.000000"         
[58] "sto_xyz:2      0.000000  2.000000  0.000000  -126.000000"        
[59] "sto_xyz:3      0.000000  0.000000  2.000000  -72.000000"         
[60] "sto_xyz:4      0.000000  0.000000  0.000000  1.000000"           
[61] "sform_xorient  Right-to-Left"                                    
[62] "sform_yorient  Posterior-to-Anterior"                            
[63] "sform_zorient  Inferior-to-Superior"                             
[64] "file_type      NIFTI-1+"                                         
[65] "file_code      1"                                                
[66] "descrip        FSL5.0"                                           
[67] "aux_file       "                                                 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslhd", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslhd.help")
> ### * fslhd.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslhd.help
> ### Title: FSLhd help
> ### Aliases: fslhd.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslhd.help()
+ }   
Usage: fslhd [-x] <input>       -x : instead print an XML-style NIFTI header

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslhd.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslhd.parse")
> ### * fslhd.parse
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslhd.parse
> ### Title: Parse FSL Header
> ### Aliases: fslhd.parse
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mnifile = file.path(fsldir(), "data", "standard", 
+    "MNI152_T1_2mm.nii.gz")
+  hd = fslhd(mnifile)
+  fslhd.parse(hd)
+ }  
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslhd "/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz" 

                                                           value
filename       /usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz
sizeof_hdr                                                   348
data_type                                                  INT16
dim0                                                           3
dim1                                                          91
dim2                                                         109
dim3                                                          91
dim4                                                           1
dim5                                                           1
dim6                                                           1
dim7                                                           1
vox_units                                                     mm
time_units                                                     s
datatype                                                       4
nbyper                                                         2
bitpix                                                        16
pixdim0                                                 0.000000
pixdim1                                                 2.000000
pixdim2                                                 2.000000
pixdim3                                                 2.000000
pixdim4                                                 1.000000
pixdim5                                                 0.000000
pixdim6                                                 0.000000
pixdim7                                                 0.000000
vox_offset                                                   352
cal_max                                                8000.0000
cal_min                                                3000.0000
scl_slope                                               1.000000
scl_inter                                               0.000000
phase_dim                                                      0
freq_dim                                                       0
slice_dim                                                      0
slice_name                                               Unknown
slice_code                                                     0
slice_start                                                    0
slice_end                                                      0
slice_duration                                          0.000000
time_offset                                             0.000000
intent                                                   Unknown
intent_code                                                    0
intent_name                                                 <NA>
intent_p1                                               0.000000
intent_p2                                               0.000000
intent_p3                                               0.000000
qform_name                                               MNI_152
qform_code                                                     4
qto_xyz:1                 -2.000000 0.000000 -0.000000 90.000000
qto_xyz:2                0.000000 2.000000 -0.000000 -126.000000
qto_xyz:3                  0.000000 0.000000 2.000000 -72.000000
qto_xyz:4                    0.000000 0.000000 0.000000 1.000000
qform_xorient                                      Right-to-Left
qform_yorient                              Posterior-to-Anterior
qform_zorient                               Inferior-to-Superior
sform_name                                               MNI_152
sform_code                                                     4
sto_xyz:1                  -2.000000 0.000000 0.000000 90.000000
sto_xyz:2                 0.000000 2.000000 0.000000 -126.000000
sto_xyz:3                  0.000000 0.000000 2.000000 -72.000000
sto_xyz:4                    0.000000 0.000000 0.000000 1.000000
sform_xorient                                      Right-to-Left
sform_yorient                              Posterior-to-Anterior
sform_zorient                               Inferior-to-Superior
file_type                                               NIFTI-1+
file_code                                                      1
descrip                                                   FSL5.0
aux_file                                                    <NA>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslhd.parse", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslindex.help")
> ### * fslindex.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslindex.help
> ### Title: fslindex Help
> ### Aliases: fslindex.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslindex.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslindex.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fsllog.help")
> ### * fsllog.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsllog.help
> ### Title: fsllog Help
> ### Aliases: fsllog.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fsllog.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fsllog.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslmask.help")
> ### * fslmask.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslmask.help
> ### Title: fslmask Help
> ### Aliases: fslmask.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslmask.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslmask.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslmaths.help")
> ### * fslmaths.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslmaths.help
> ### Title: FSL Maths Help
> ### Aliases: fslmaths.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslmaths.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslmaths.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslmerge.help")
> ### * fslmerge.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslmerge.help
> ### Title: FSLMerge help
> ### Aliases: fslmerge.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslmerge.help()
+ }  
Usage: fslmerge <-x/y/z/t/a/tr> <output> <file1 file2 .......> [tr value in seconds]     -t : concatenate images in time     -x : concatenate images in the x direction     -y : concatenate images in the y direction     -z : concatenate images in the z direction     -a : auto-choose: single slices -> volume, volumes -> 4D (time series)     -tr : concatenate images in time and set the output image tr to the final option value

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslmerge.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslmin_max")
> ### * fslmin_max
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslmax
> ### Title: Get min/max of an image
> ### Aliases: fslmax fslmin
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mnifile = file.path(fsldir(), "data", "standard", 
+    "MNI152_T1_2mm.nii.gz")
+  fslmax(mnifile)
+ }  
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslstats  "/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz" -R

[1] 9968
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslmin_max", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslmul.help")
> ### * fslmul.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslmul.help
> ### Title: fslmul Help
> ### Aliases: fslmul.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslmul.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslmul.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslnan.help")
> ### * fslnan.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslnan.help
> ### Title: fslnan Help
> ### Aliases: fslnan.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslnan.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslnan.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslnanm.help")
> ### * fslnanm.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslnanm.help
> ### Title: fslnanm Help
> ### Aliases: fslnanm.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslnanm.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslnanm.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslorient.help")
> ### * fslorient.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslorient.help
> ### Title: fslorient help
> ### Aliases: fslorient.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslorient.help()
+ } 
Usage: fslorient <main option> <filename>  where the main option is one of:    -getorient             (prints FSL left-right orientation)    -getsform              (prints the 16 elements of the sform matrix)    -getqform              (prints the 16 elements of the qform matrix)    -setsform <m11 m12 ... m44>  (sets the 16 elements of the sform matrix)    -setqform <m11 m12 ... m44>  (sets the 16 elements of the qform matrix)    -getsformcode          (prints the sform integer code)    -getqformcode          (prints the qform integer code)    -setsformcode <code>   (sets sform integer code)    -setqformcode <code>   (sets qform integer code)    -copysform2qform       (sets the qform equal to the sform - code and matrix)    -copyqform2sform       (sets the sform equal to the qform - code and matrix)    -deleteorient          (removes orient info from header)    -forceradiological     (makes FSL radiological header)    -forceneurological     (makes FSL neurological header - not Analyze)    -swaporient            (swaps FSL radiological and FSL neurological)       Note: the stored data order is never changed here - only the header info.       To change the data storage use fslswapdim.  e.g.  fslorient -forceradiological myimage        fslorient -copysform2qform myimage        fslorient -setsform -2 0 0 90 0 2 0 -126 0 0 2 -72 0 0 0 1 myimage

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslorient.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslrand.help")
> ### * fslrand.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslrand.help
> ### Title: fslrand Help
> ### Aliases: fslrand.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslrand.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslrand.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslrandn.help")
> ### * fslrandn.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslrandn.help
> ### Title: fslrandn Help
> ### Aliases: fslrandn.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslrandn.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslrandn.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslrange")
> ### * fslrange
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslrange
> ### Title: Get range of an image
> ### Aliases: fslrange
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mnifile = file.path(fsldir(), "data", "standard", 
+    "MNI152_T1_2mm.nii.gz")
+  fslrange(mnifile)
+ }  
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslstats  "/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz" -R

[1]    0 9968
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslrange", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslrecip.help")
> ### * fslrecip.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslrecip.help
> ### Title: fslrecip Help
> ### Aliases: fslrecip.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslrecip.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslrecip.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslrem.help")
> ### * fslrem.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslrem.help
> ### Title: fslrem Help
> ### Aliases: fslrem.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslrem.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslrem.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslreorient2std.help")
> ### * fslreorient2std.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslreorient2std.help
> ### Title: fslreorient2std help
> ### Aliases: fslreorient2std.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslreorient2std.help()
+ }  
Usage: fslreorient2std <input_image> [output_image] fslreorient2std is a tool for reorienting the image to match theapproximate orientation of the standard template images (MNI152).It only applies 0, 90, 180 or 270 degree rotations.It is not a registration tool.It requires NIfTI images with valid orientation informationin them (seen by valid labels in FSLView).  This toolassumes the labels are correct - if not, fix that before using this.If the output name is not specified the equivalent transformation matrix is written to the standard output 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslreorient2std.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsin.help")
> ### * fslsin.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslsin.help
> ### Title: fslsin Help
> ### Aliases: fslsin.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslsin.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsin.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsmooth")
> ### * fslsmooth
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_smooth
> ### Title: Gaussian smooth image using FSL
> ### Aliases: fsl_smooth fslsmooth
> 
> ### ** Examples
> 
> if (have.fsl()){
+ system.time({
+ dims = c(50, 50, 20)
+ x = array(rnorm(prod(dims)), dim = dims)
+ img = nifti(x, dim= dims, 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ s.img = fslsmooth(img, retimg=TRUE)
+ })
+ }
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d621829bce6.nii.gz"  -s 10 "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d625c30ac6e";

   user  system elapsed 
  0.137   0.027   0.169 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsmooth", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsmooth.help")
> ### * fslsmooth.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslsmooth.help
> ### Title: fslsmooth Help
> ### Aliases: fslsmooth.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslsmooth.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsmooth.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsmooth_in_mask")
> ### * fslsmooth_in_mask
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslsmooth_in_mask
> ### Title: Smooth Image Within a Mask Only
> ### Aliases: fslsmooth_in_mask fsl_smooth_in_mask
> 
> ### ** Examples
> 
> if (have.fsl()){
+ system.time({
+ dims = c(50, 50, 20)
+ x = array(rnorm(prod(dims)), dim = dims)
+ img = nifti(x, dim= dims, 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ mask = abs(img ) > 1
+ s.img = fslsmooth_in_mask(img, mask = mask)
+ })
+ }
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d627f88990a.nii.gz"  -mas "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6260f7a0ef.nii.gz"  -s 10 "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d622166dca5"; FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6260f7a0ef.nii.gz" -s 10 "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6260f7a0ef_10"; FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d622166dca5" -div "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6260f7a0ef_10" -mas "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d6260f7a0ef.nii.gz" "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d622166dca5";

   user  system elapsed 
  0.524   0.046   0.585 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsmooth_in_mask", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsplit.help")
> ### * fslsplit.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslsplit.help
> ### Title: FSL Split help
> ### Aliases: fslsplit.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslsplit.help()
+ }  
Usage: fslsplit <input>       fslsplit <input> [output_basename] [-t/x/y/z]       -t : separate images in time (default behaviour)       -x : separate images in the x direction       -y : separate images in the y direction       -z : separate images in the z direction

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsplit.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsqr.help")
> ### * fslsqr.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslsqr.help
> ### Title: fslsqr Help
> ### Aliases: fslsqr.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslsqr.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsqr.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsqrt.help")
> ### * fslsqrt.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslsqrt.help
> ### Title: fslsqrt Help
> ### Aliases: fslsqrt.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslsqrt.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsqrt.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslstats")
> ### * fslstats
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslstats
> ### Title: FSL Stats
> ### Aliases: fslstats
> 
> ### ** Examples
> 
> if (have.fsl()){
+ system.time({
+ x = array(rnorm(1e6), dim = c(100, 100, 100))
+ img = nifti(x, dim= c(100, 100, 100), 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ entropy = fslstats(img, opts='-E')
+ })
+ }  
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslstats  "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d62681fe5c4.nii.gz" -E

   user  system elapsed 
  1.071   0.189   1.281 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslstats", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslstats.help")
> ### * fslstats.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslstats.help
> ### Title: FSL Stats Help
> ### Aliases: fslstats.help fslrange.help fslmean.help fslentropy.help
> ###   fslsd.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslstats.help() 
+ }
Usage: fslstats [preoptions] <input> [options]preoption -t will give a separate output line for each 3D volume of a 4D timeseriespreoption -K < indexMask > will generate seperate n submasks from indexMask, for indexvalues 1..n where n is the maximum index value in indexMask, and generate statistics for each submaskNote - options are applied in order, e.g. -M -l 10 -M will report the non-zero mean, apply a threshold and then report the new nonzero mean-l <lthresh> : set lower threshold-u <uthresh> : set upper threshold-r           : output <robust min intensity> <robust max intensity>-R           : output <min intensity> <max intensity>-e           : output mean entropy ; mean(-i*ln(i))-E           : output mean entropy (of nonzero voxels)-v           : output <voxels> <volume>-V           : output <voxels> <volume> (for nonzero voxels)-m           : output mean-M           : output mean (for nonzero voxels)-s           : output standard deviation-S           : output standard deviation (for nonzero voxels)-w           : output smallest ROI <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> containing nonzero voxels-x           : output co-ordinates of maximum voxel-X           : output co-ordinates of minimum voxel-c           : output centre-of-gravity (cog) in mm coordinates-C           : output centre-of-gravity (cog) in voxel coordinates-p <n>       : output nth percentile (n between 0 and 100)-P <n>       : output nth percentile (for nonzero voxels)-a           : use absolute values of all image intensities-n           : treat NaN or Inf as zero for subsequent stats-k <mask>    : use the specified image (filename) for masking - overrides lower and upper thresholds-d <image>   : take the difference between the base image and the image specified here-h <nbins>   : output a histogram (for the thresholded/masked voxels only) with nbins-H <nbins> <min> <max>   : output a histogram (for the thresholded/masked voxels only) with nbins and histogram limits of min and maxNote - thresholds are not inclusive ie lthresh<allowed<uthresh

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslstats.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsub.help")
> ### * fslsub.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslsub.help
> ### Title: fslsub Help
> ### Aliases: fslsub.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslsub.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsub.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsub2")
> ### * fslsub2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_sub2
> ### Title: Subsample image by factor of 2
> ### Aliases: fsl_sub2 fslsub2
> 
> ### ** Examples
> 
> if (have.fsl()){
+ system.time({
+ x = array(rnorm(1e6), dim = c(100, 100, 100))
+ img = nifti(x, dim= c(100, 100, 100), 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ subsamp = fslsub2(img, retimg=TRUE)
+ print(voxdim(subsamp))
+ })
+ } 
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d62625dc44.nii.gz"  -subsamp2 "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d621f9ff783";

[1] 2 2 2
   user  system elapsed 
  0.770   0.214   0.994 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsub2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslsub2.help")
> ### * fslsub2.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslsub2.help
> ### Title: fslsub2 Help
> ### Aliases: fslsub2.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslsub2.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslsub2.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslswapdim.help")
> ### * fslswapdim.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslswapdim.help
> ### Title: fslswapdim help
> ### Aliases: fslswapdim.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslswapdim.help()
+ }  
Usage: fslswapdim <input> <a> <b> <c> [output]  where a,b,c represent the new x,y,z axes in terms of the  old axes.  They can take values of -x,x,y,-y,z,-z  or RL,LR,AP,PA,SI,IS (in the case of nifti inputs)  e.g.  fslswapdim invol y x -z outvol  or    fslswapdim invol RL PA IS outvol  where the latter will convert to axial slicing   (to match the avg152 images)

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslswapdim.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fsltan.help")
> ### * fsltan.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsltan.help
> ### Title: fsltan Help
> ### Aliases: fsltan.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fsltan.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fsltan.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslthresh")
> ### * fslthresh
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fsl_thresh
> ### Title: Threshold an image
> ### Aliases: fsl_thresh fslthresh
> 
> ### ** Examples
> 
> if (have.fsl()){
+ system.time({
+ x = array(rnorm(1e6), dim = c(100, 100, 100))
+ img = nifti(x, dim= c(100, 100, 100), 
+ datatype = convert.datatype()$FLOAT32, cal.min = min(x), 
+ cal.max = max(x), pixdim = rep(1, 4))
+ thresh = fslthresh(img, thresh=0, uthresh = 2, retimg=TRUE)
+ })
+ } 
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslmaths "/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZhhuVX/file16d621f569d45.nii.gz" -thr 0.000000 -uthr 2.000000  "/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZhhuVX/file16d623f32c9ad"

   user  system elapsed 
  1.246   0.413   1.676 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslthresh", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslthresh.help")
> ### * fslthresh.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslthresh.help
> ### Title: fslthresh Help
> ### Aliases: fslthresh.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslthresh.help() 
+ }
Usage: fslmaths [-dt <datatype>] <first_input> [operations and inputs] <output> [-odt <datatype>]Datatype information: -dt sets the datatype used internally for calculations (default float for all except double images) -odt sets the output datatype ( default is float ) Possible datatypes are: char short int float double input "input" will set the datatype to that of the original imageBinary operations:  (some inputs can be either an image or a number) -add   : add following input to current image -sub   : subtract following input from current image -mul   : multiply current image by following input -div   : divide current image by following input -rem   : modulus remainder - divide current image by following input and take remainder -mas   : use (following image>0) to mask current image -thr   : use following number to threshold current image (zero anything below the number) -thrp  : use following percentage (0-100) of ROBUST RANGE to threshold current image (zero anything below the number) -thrP  : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold below -uthr  : use following number to upper-threshold current image (zero anything above the number) -uthrp : use following percentage (0-100) of ROBUST RANGE to upper-threshold current image (zero anything above the number) -uthrP : use following percentage (0-100) of ROBUST RANGE of non-zero voxels and threshold above -max   : take maximum of following input and current image -min   : take minimum of following input and current image -seed  : seed random number generator with following number -restart : replace the current image with input for future processing operations -save : save the current working image to the input filenameBasic unary operations: -exp   : exponential -log   : natural logarithm -sin   : sine function -cos   : cosine function -tan   : tangent function -asin  : arc sine function -acos  : arc cosine function -atan  : arc tangent function -sqr   : square -sqrt  : square root -recip : reciprocal (1/current image) -abs   : absolute value -bin   : use (current image>0) to binarise -binv  : binarise and invert (binarisation and logical inversion) -fillh : fill holes in a binary mask (holes are internal - i.e. do not touch the edge of the FOV) -fillh26 : fill holes using 26 connectivity -index : replace each nonzero voxel with a unique (subject to wrapping) index number -grid <value> <spacing> : add a 3D grid of intensity <value> with grid spacing <spacing> -edge  : edge strength -tfce <H> <E> <connectivity>: enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for skeletons) -tfceS <H> <E> <connectivity> <X> <Y> <Z> <tfce_thresh>: show support area for voxel (X,Y,Z) -nan   : replace NaNs (improper numbers) with 0 -nanm  : make NaN (improper number) mask with 1 for NaN voxels, 0 otherwise -rand  : add uniform noise (range 0:1) -randn : add Gaussian noise (mean=0 sigma=1) -inm <mean> :  (-i i ip.c) intensity normalisation (per 3D volume mean) -ing <mean> :  (-I i ip.c) intensity normalisation, global 4D mean) -range : set the output calmin/max to full data rangeMatrix operations: -tensor_decomp : convert a 4D (6-timepoint )tensor image into L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA)Kernel operations (set BEFORE filtering operation if desired): -kernel 3D : 3x3x3 box centered on target voxel (set as default kernel) -kernel 2D : 3x3x1 box centered on target voxel -kernel box    <size>     : all voxels in a cube of width <size> mm centered on target voxel -kernel boxv   <size>     : all voxels in a cube of width <size> voxels centered on target voxel, CAUTION: size should be an odd number -kernel boxv3  <X> <Y> <Z>: all voxels in a cuboid of dimensions X x Y x Z centered on target voxel, CAUTION: size should be an odd number -kernel gauss  <sigma>    : gaussian kernel (sigma in mm, not voxels) -kernel sphere <size>     : all voxels in a sphere of radius <size> mm centered on target voxel -kernel file   <filename> : use external file as kernelSpatial Filtering operations: N.B. all options apart from -s use the default kernel or that _previously_ specified by -kernel -dilM    : Mean Dilation of non-zero voxels -dilD    : Modal Dilation of non-zero voxels -dilF    : Maximum filtering of all voxels -dilall  : Apply -dilM repeatedly until the entire FOV is covered -ero     : Erode by zeroing non-zero voxels when zero voxels found in kernel -eroF    : Minimum filtering of all voxels -fmedian : Median Filtering  -fmean   : Mean filtering, kernel weighted (conventionally used with gauss kernel) -fmeanu  : Mean filtering, kernel weighted, un-normalised (gives edge effects) -s <sigma> : create a gauss kernel of sigma mm and perform mean filtering -subsamp2  : downsamples image by a factor of 2 (keeping new voxels centred on old) -subsamp2offc  : downsamples image by a factor of 2 (non-centred)Dimensionality reduction operations:  (the "T" can be replaced by X, Y or Z to collapse across a different dimension) -Tmean   : mean across time -Tstd    : standard deviation across time -Tmax    : max across time -Tmaxn   : time index of max across time -Tmin    : min across time -Tmedian : median across time -Tperc <percentage> : nth percentile (0-100) of FULL RANGE across time -Tar1    : temporal AR(1) coefficient (use -odt float and probably demean first)Basic statistical operations: -pval    : Nonparametric uncorrected P-value, assuming timepoints are the permutations; first timepoint is actual (unpermuted) stats image -pval0   : Same as -pval, but treat zeros as missing data -cpval   : Same as -pval, but gives FWE corrected P-values -ztop    : Convert Z-stat to (uncorrected) P -ptoz    : Convert (uncorrected) P to Z -rank    : Convert data to ranks (over T dim) -ranknorm: Transform to Normal dist via ranksMulti-argument operations: -roi <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize> : zero outside roi (using voxel coordinates). Inputting -1 for a size will set it to the full image extent for that dimension. -bptf  <hp_sigma> <lp_sigma> : (-t in ip.c) Bandpass temporal filtering; nonlinear highpass and Gaussian linear lowpass (with sigmas in volumes, not seconds); set either sigma<0 to skip that filter -roc <AROC-thresh> <outfile> [4Dnoiseonly] <truth> : take (normally binary) truth and test current image in ROC analysis against truth. <AROC-thresh> is usually 0.05 and is limit of Area-under-ROC measure FP axis. <outfile> is a text file of the ROC curve (triplets of values: FP TP threshold). If the truth image contains negative voxels these get excluded from all calculations. If <AROC-thresh> is positive then the [4Dnoiseonly] option needs to be set, and the FP rate is determined from this noise-only data, and is set to be the fraction of timepoints where any FP (anywhere) is seen, as found in the noise-only 4d-dataset. This is then controlling the FWE rate. If <AROC-thresh> is negative the FP rate is calculated from the zero-value parts of the <truth> image, this time averaging voxelwise FP rate over all timepoints. In both cases the TP rate is the average fraction of truth=positive voxels correctly found.Combining 4D and 3D images: If you apply a Binary operation (one that takes the current image and a new image together), when one is 3D and the other is 4D, the 3D image is cloned temporally to match the temporal dimensions of the 4D image.e.g. fslmaths inputVolume -add inputVolume2 output_volume     fslmaths inputVolume -add 2.5 output_volume     fslmaths inputVolume -add 2.5 -mul inputVolume2 output_volume     fslmaths 4D_inputVolume -Tmean -mul -1 -add 4D_inputVolume demeaned_4D_inputVolume

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslthresh.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslval")
> ### * fslval
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslval
> ### Title: Get value from FSL header
> ### Aliases: fslval
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mnifile = file.path(fsldir(), "data", "standard", 
+    "MNI152_T1_2mm.nii.gz")
+  fslval(mnifile, keyword = "dim1")
+ }  
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslval "/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz" dim1

[1] "91"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslval", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslval.help")
> ### * fslval.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslval.help
> ### Title: fslval help
> ### Aliases: fslval.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslval.help()
+ } 
Usage: fslval <input> <keyword>

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslval.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fslview.help")
> ### * fslview.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fslview.help
> ### Title: FSLView help
> ### Aliases: fslview.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  fslview.help()
+ }   
Fslview is now deprecated, please type:fsleyesto launch our great new image viewer, or type:fslview_deprecatedto launch the old fslview

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fslview.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("getForms")
> ### * getForms
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getForms
> ### Title: Get Q and S Forms of orientation matrix
> ### Aliases: getForms
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mnifile = file.path(fsldir(), "data", "standard", 
+    "MNI152_T1_2mm.nii.gz")
+  getForms(mnifile)
+ }   
FSLDIR='/usr/local/fsl'; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh "${FSLDIR}/etc/fslconf/fsl.sh"; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslhd "/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz" 

$qform
     [,1] [,2] [,3] [,4]
[1,]   -2    0    0   90
[2,]    0    2    0 -126
[3,]    0    0    2  -72
[4,]    0    0    0    1

$sform
     [,1] [,2] [,3] [,4]
[1,]   -2    0    0   90
[2,]    0    2    0 -126
[3,]    0    0    2  -72
[4,]    0    0    0    1

$sor
[1] "sform_xorient  Right-to-Left"        
[2] "sform_yorient  Posterior-to-Anterior"
[3] "sform_zorient  Inferior-to-Superior" 

$qor
[1] "qform_xorient  Right-to-Left"        
[2] "qform_yorient  Posterior-to-Anterior"
[3] "qform_zorient  Inferior-to-Superior" 

$ssor
[1] "RL" "PA" "IS"

$sqor
[1] "RL" "PA" "IS"

$sform_code
[1] 4

$qform_code
[1] 4

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getForms", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("have.fsl")
> ### * have.fsl
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: have.fsl
> ### Title: Logical check if FSL is accessible
> ### Aliases: have.fsl have_fsl
> 
> ### ** Examples
> 
> have.fsl()
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("have.fsl", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mcflirt.help")
> ### * mcflirt.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mcflirt.help
> ### Title: MCFLIRT help
> ### Aliases: mcflirt.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  mcflirt.help()
+ } 
Usage: mcflirt -in <infile> [options]  Available options are:        -out, -o <outfile>               (default is infile_mcf)        -cost {mutualinfo,woods,corratio,normcorr,normmi,leastsquares}        (default is normcorr)        -bins <number of histogram bins>   (default is 256)        -dof  <number of transform dofs>   (default is 6)        -refvol <number of reference volume> (default is no_vols/2)- registers to (n+1)th volume in series        -reffile, -r <filename>            use a separate 3d image file as the target for registration (overrides refvol option)        -scaling <num>                             (6.0 is default)        -smooth <num>                      (1.0 is default - controls smoothing in cost function)        -rotation <num>                    specify scaling factor for rotation optimization tolerances        -verbose <num>                     (0 is least and default)        -stages <number of search levels>  (default is 3 - specify 4 for final sinc interpolation)        -fov <num>                         (default is 20mm - specify size of field of view when padding 2d volume)        -2d                                Force padding of volume        -sinc_final                        (applies final transformations using sinc interpolation)        -spline_final                      (applies final transformations using spline interpolation)        -nn_final                          (applies final transformations using Nearest Neighbour interpolation)        -init <filename>                   (initial transform matrix to apply to all vols)        -gdt                               (run search on gradient images)        -meanvol                           register timeseries to mean volume (overrides refvol and reffile options)        -stats                             produce variance and std. dev. images        -mats                              save transformation matricies in subdirectory outfilename.mat        -plots                             save transformation parameters in file outputfilename.par        -report                            report progress to screen        -help

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mcflirt.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("melodic.help")
> ### * melodic.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: melodic.help
> ### Title: MELODIC help
> ### Aliases: melodic.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  melodic.help()
+ } 

Part of FSL (ID: 5.0.10)
MELODIC (Version 3.15)
 Multivariate Exploratory Linear Optimised Decomposition into Independent Components

Author: Christian F. Beckmann 
 Copyright(c) 2001-2013 University of Oxford

Usage: 
 melodic -i <filename> <options>
 	 	 to run melodic
 melodic -i <filename> --ICs=melodic_IC --mix=melodic_mix <options>
 	 	 to run Mixture Model based inference on estimated ICs
 melodic --help 

Compulsory arguments (You MUST set one or more of):
	-i,--in	input file names (either single file name or comma-separated list or text file)

Optional arguments (You may optionally specify one or more of):
	-o,--outdir	output directory name
	--Oall	        output everything
	-m,--mask	file name of mask for thresholding
	-d,--dim	dimensionality reduction into #num dimensions (default: automatic estimation)
	-a,--approach	approach for multi-session/subject data:
	   concat	temporally-concatenated group-ICA using MIGP ( default )
	   tica  	tensor-ICA
	--report	generate Melodic web report
	--CIFTI	        input/output as CIFTI (warning: auto-dimensionality estimation for CIFTI data is currently inaccurate)
	--vn,--varnorm	switch off variance normalisation
	-v,--verbose	switch on diagnostic messages



	--nomask	switch off masking
	--update_mask	switch off mask updating
	--nobet		switch off BET
	--bgthreshold	brain / non-brain threshold (only if --nobet selected)

	--dimest	use specific dim. estimation technique: lap, bic, mdl, aic, mean (default: lap)
	--sep_vn	switch on separate variance nomalisation for each input dataset (off by default)
	--disableMigp	switch off MIGP data reduction when using -a concat (full temporal concatenation will be used)
	--migpN	Number of internal Eigenmaps
	--migp_shuffle	Randomise MIGP file order (default: TRUE)
	--migp_factor	Internal Factor of mem-threshold relative to number of Eigenmaps (default: 2)
	-n,--numICs	numer of IC's to extract (for deflation approach)
	--nl		nonlinearity: gauss, tanh, pow3, pow4
	--covarweight	voxel-wise weights for the covariance matrix (e.g. segmentation information)
	--eps	minimum error change
	--epsS	minimum error change for rank-1 approximation in TICA
	--maxit		maximum number of iterations before restart
	--maxrestart	maximum number of restarts

	--mmthresh	threshold for Mixture Model based inference
	--no_mm		switch off mixture modelling on IC maps
 
	--ICs		input filename of the IC components file for mixture modelling
	--mix		input filename of mixing matrix for mixture modelling / filtering
	--smode		input filename of matrix of session modes for report generation
	-f,--filter	list of component numbers to remove
 
	--bgimage	specify background image for report (default: mean image)
 
	--tr		TR in seconds
	--logPower	calculate log of power for frequency spectrum

	--Tdes	        design matrix across time-domain
	--Tcon	        t-contrast matrix across time-domain
	--Sdes	        design matrix across subject-domain
	--Scon	        t-contrast matrix across subject-domain
	--Ounmix	output unmixing matrix
	--Ostats	output thresholded maps and probability maps
	--Opca		output PCA results
	--Owhite	output whitening/dewhitening matrices
	--Oorig		output the original ICs
	--Omean		output mean volume

	-V,--version	prints version information
	--copyright	prints copyright information
	-h,--help	prints this help message
	--debug	        switch on debug messages
	--report_maps	control string for spatial map images (see slicer)




> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("melodic.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("run_first_all.help")
> ### * run_first_all.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: run_first_all.help
> ### Title: Run FIRST All Help
> ### Aliases: run_first_all.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  run_first_all.help() 
+ }
Usage: run_first_all [options] -i <input_image> -o <output_image>Optional arguments:  -m <method>      : method must be one of auto, fast, none or a (numerical) threshold value  -b               : input is already brain extracted  -s <name>        : run only on one specified structure (e.g. L_Hipp) or a comma separated list (no spaces)  -a <img2std.mat> : use affine matrix (do not re-run registration)  -3               : use 3-stage affine registration (only currently for hippocampus)  -d               : do not cleanup image output files (useful for debugging)  -v               : verbose output  -h               : display this help messagee.g.:  run_first_all -i im1 -o output_name 

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("run_first_all.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("susan.help")
> ### * susan.help
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: susan.help
> ### Title: FSL SUSAN Help
> ### Aliases: susan.help
> 
> ### ** Examples
> 
> if (have.fsl()){
+  susan.help() 
+ }
Usage: susan <input> <bt> <dt> <dim> <use_median> <n_usans> [<usan1> <bt1> [<usan2> <bt2>]] <output><bt> is brightness threshold and should be greater than noise level and less than contrast of edges to be preserved.<dt> is spatial size (sigma, i.e., half-width) of smoothing, in mm.<dim> is dimensionality (2 or 3), depending on whether smoothing is to be within-plane (2) or fully 3D (3).<use_median> determines whether to use a local median filter in the cases where single-point noise is detected (0 or 1).<n_usans> determines whether the smoothing area (USAN) is to be found from secondary images (0, 1 or 2).A negative value for any brightness threshold will auto-set the threshold at 10% of the robust range

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("susan.help", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  6.658 1.15 11.734 2.119 0.426 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
